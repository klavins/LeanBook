<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>λ-Calculus - Foundations of Lean</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A light introduction to the foundations of mathematics and proof checking with Lean">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="lean-book.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Foundations of Lean</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/klavins/LeanBook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style='display:none'>
--  Copyright (C) 2025  Eric Klavins
--
--  This program is free software: you can redistribute it and/or modify
--  it under the terms of the GNU General Public License as published by
--  the Free Software Foundation, either version 3 of the License, or
--  (at your option) any later version.   
</div>
<p><span style='color: orange'><em><strong>UNDER CONSTRUCTION</strong></em></span><br>
<span style='color: lightgray; font-size: 10pt'><a href='https://github.com/klavins/LeanBook/blob/main/main/../LeanBook/Chapters/LambdaCalculus.lean'>Code</a> for this chapter</span></p>
<h1 id="the-simply-typed-λ-lambda-calculus"><a class="header" href="#the-simply-typed-λ-lambda-calculus">The Simply Typed λ-Lambda Calculus</a></h1>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>The <strong>λ-calculus</strong> was introduced in the 1930s by Alonzo Church as a way to represent how functions on natural numbers are calculated using symbols. The goal was to determine whether every function on the natural numbers had an effective means of being calculated.</p>
<p>Said differently, the question is: Does every function have an algorithm? Astonishingly, Church showed that the answer is "no". In fact, there are functions on the natural numbers for which there is no effective algorithm. Church's 1935 paper "An unsolvable problem in elementary number theory" proved this result.</p>
<p>The reasoning, roughly, is this:</p>
<ul>
<li>Devise a simple programming language, the λ-calculus</li>
<li>Define computation as rewriting operations on λ-calculus terms</li>
<li>Correspond to every term a natural number</li>
<li>Conclude that questions about terms are thus questions about numbers</li>
<li>Show there are more functions from terms into terms than there are terms.</li>
</ul>
<p>A specific problem that Church showed to be unsolvable is: Given λ-calculus terms M and N, show there does not exist a λ-calculus function that can determine whether M can be rewritten as N. Those who have studied theoretical computer science, may be familiar with Alan Turing's similar result which shows there is no Turing Machine that can determine whether a given Turing Machine eventually terminates. In fact, the λ-calculus can simulate Turing Machines and vice verse.</p>
<p>The Church-Turing Thesis is the observation that <em>all</em> formalizations of computation are in fact equivalent to the λ-calculus or, equivalently, Turing Machines. The former is more convenient for symbolic reasoning, while the latter is more akin to how electromechanical computers actually work.</p>
<h2 id="programming-languages"><a class="header" href="#programming-languages">Programming Languages</a></h2>
<p>Thus, the λ-calclus and the formal notion of computation has its roots in the foundations of mathematics. Later, around the 1960s, linguists and computer scientists realized that the λ-calculus was an useful framework for the theory and design of programming languages.</p>
<p>Simultaenously, logicians were becoming frustrated with Set Theory as a foundation for mathematics and started exploring Type Theory as an alternative. Around the 1990s many of these ideas came together, especially through the work of Thierry Coquand on the Calculus of Constructions. It was observed that typed programming languages were not only an ideal foundation for all of mathematics, they could be used to develop computational proof assistants and theoerm provers.</p>
<h2 id="currys-paradox"><a class="header" href="#currys-paradox">Curry's Paradox</a></h2>
<p>The original formulation of the λ-calculus allowed for infinite loops, as do most programming languages. This made the λ-calculus expressive enough for Church to prove his undecidability results, but it caused other problems when logicians wished to use formalisms like the λ-calculus as systems of logic.</p>
<p>Haskel Curry discovered that one could encode the following paradox:</p>
<ul>
<li>Consider the self-referential statement X = X → Y where Y is <em>any</em> statement.</li>
<li>Certainly X → X is true for any statement X.</li>
<li>Substituting X → Y for the second X gives X → (X → Y)</li>
<li>This statement is equivalent to X → Y, which is the same as X</li>
<li>Thus X is true</li>
<li>So Y is true since X → Y</li>
</ul>
<p>For example, X → Y could mean "If this sentence is true, then 1 &gt; 0." Any framework in which you can make this argument allows you to prove any statement Y, and so the framework is useless logically.</p>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>The solution was to give <em>types</em> to all terms in the λ-calculus. We will see below that certain self referential programs are impossible to assign types to. At the same time, infinite loops are no longer allowed, making the formalism not as powerful from a computational point of view.</p>
<p>Thus was born the <em>simply-typed λ-calculus</em>. Eventually, more complicated types were added, in which type definitions could depend on other types or on even terms. Most modern programming languages and some logical frameworks have these properties.</p>
<p>Church's paper on the subject is quite complicated, elucidating ideas that were fairly novel at the time. Since then, comptuer scientists have refined the ideas into a very simple framework, which is presented here, and which can be found in numerous textbooks. The notes in the first part of this section follow video lectures by students of Prof. Uwe Nestmann at the Technical University of Berlin, except that I have restated the formulas in Lean. A link to the videos can be found in the references at the end of this chapter. A Google search will yield hundreds of similar lectures, notes, books, and papers.</p>
<h3 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h3>
<p>The <code>simply typed λ-calculus</code> is an extremely simple programming language that nevertheless captures the essence of computation. It uses type expressions and terms that have those types. We start with the types. First, we assume a base type. In Lean the base type is called <code>Type</code>. You can ask lean what <code>Type</code> is using the <code>#check</code> directive (which stands for "Type Check").</p>
<pre><code class="language-lean">#check Type
</code></pre>
<p>Lean tells you <code>Type</code> has <code>Type 1</code>, which is a synonym for <code>Type</code>. Don't worry about this right now and just accept that <code>Type</code> is a type. One constructs new types using the arrow <code>→</code> as in the following examples:</p>
<pre><code class="language-lean">#check Type → Type
#check Type → (Type → Type)
#check (Type → Type) → Type
</code></pre>
<p>That is, whenevever τ is a type, so is τ → τ. Arrow types are supposed to denote function types. So τ → τ is the type of any function that takes objects in τ and returns objects in τ. Note that the arrow → associates to the right. So the second expression above is equivalent to <code>Type → Type → Type</code>.</p>
<h3 id="type-variables-and-applications"><a class="header" href="#type-variables-and-applications">Type Variables and Applications</a></h3>
<p>You can also define type variables using <code>def</code></p>
<pre><code class="language-lean">def A := Type
def B := Type → Type
</code></pre>
<p>Which looks a bit more like what you would see in a textbook on type theory. Now you can construct more types.</p>
<pre><code class="language-lean">#check A → B
</code></pre>
<h2 id="terms"><a class="header" href="#terms">Terms</a></h2>
<p>Next, we define the terms of the lambda calculus. These are the programs. We start with <strong>variables</strong>, for example <code>x</code> and <code>f</code>, which we declare in Lean as follows:</p>
<pre><code class="language-lean">variable (x : A)               -- declare a variable x of type a
variable (f : A → A)           -- declare a function f from A into A

#check x
#check f
</code></pre>
<p>What we've said here is that <code>x</code> is a simple object with type <code>A</code>, while <code>f</code> is an function type from <code>A</code> into <code>A</code>. Next we have <strong>applications</strong>. These have the form <code>e₁ e₁</code> where <code>e₁</code> and <code>e₂</code> are terms. For example,</p>
<pre><code class="language-lean">#check f x
#check f (f x)
#check f (f (f x))
</code></pre>
<p>are all applications of terms to terms.</p>
<h3 id="abstractions"><a class="header" href="#abstractions">Abstractions</a></h3>
<p>Finally, we have <strong>abstractions</strong>, which have the form <code>λ (x : τ) =&gt; e</code> where <code>τ</code> is a type and <code>e</code> is a term. The <code>x</code> in this expression is said to be <code>bound</code> to the abstraction. It is a dummy variable and could be renamed without any change in meaning. For example, the following are terms in the λ-calculus:</p>
<pre><code class="language-lean">#check λ (y : A) =&gt; y
#check λ (g : A → A) =&gt; λ (y : A) =&gt; g y
</code></pre>
<p>In the first example, the abstraction defines a function that simply returns its argument. In the second example, the abstraction defines a function that takes another function <code>g</code> and returns yet another abstraction that takes an object <code>y</code> and returns <code>g</code> applied to <code>y</code>.</p>
<p>Note that the parentheses group to the right, so the second example is equivalent to:</p>
<pre><code class="language-lean">#check λ (g : A → A) =&gt; ( λ (y : A) =&gt; g y )
</code></pre>
<p>In Lean, we can also abbreviate a chained lamdba abstractions by writing:</p>
<pre><code class="language-lean">#check λ (g : A → A) (y : A) =&gt; g y
</code></pre>
<h3 id="equivalence-with-def"><a class="header" href="#equivalence-with-def">Equivalence with <code>def</code></a></h3>
<p>A lambda abstraction is basically an unamed function. You could also give your functions names and use <code>def</code>.</p>
<pre><code class="language-lean">def inc₁ (x : Nat) : Nat := x + 1
def inc₂ := λ x =&gt; x + 1

#eval inc₁ 3
#eval inc₂ 3
#eval (λ x =&gt; x + 1) 3
</code></pre>
<h3 id="currying"><a class="header" href="#currying">Currying</a></h3>
<p>Consider the lambda abstraction</p>
<pre><code class="language-lean">variable (X : Type)
variable (a : X)

#check λ (g : X → X) =&gt; λ (x: X) =&gt; g x
</code></pre>
<p>If we apply the abstraction to particular function, then we get another function.</p>
<pre><code class="language-lean">#reduce (λ (g : X → X) =&gt; λ (x: X) =&gt; g x) (λ x =&gt; x)
</code></pre>
<p>This way this new function is obtained is called <em>Currying</em> after Haskel Curry. The function can then be applied again:</p>
<pre><code class="language-lean">#reduce (λ (g : X → X) =&gt; λ (x: X) =&gt; g x) (λ x =&gt; x) a
</code></pre>
<h2 id="type-derivation"><a class="header" href="#type-derivation">Type Derivation</a></h2>
<p>All <strong>terms have types</strong>. These can be found using type theory's <strong>derivation rules</strong>:</p>
<p><strong>VAR</strong>: Variables are declared either globally to have a given type (using Lean's variable command) or are bound in a λ-expression.</p>
<p><strong>ABST</strong>: The type of an abstraction is always of the form A → B where A is the type of the argument and B is the type of the result.</p>
<p><strong>APPL</strong>: If f : A → B and x : A, then the type of the application of f to x is B.</p>
<p>These derivation rules are applied automatically by Lean in the process of type checking using the #check directive. We can see the types Lean derives as follows.</p>
<pre><code class="language-lean">def h₁ := λ (y : A) =&gt; y
def h₂ := λ (g : A → A) =&gt; λ (y : A) =&gt; g y

#check x
#check h₁
#check h₂
#check h₁ x
#check h₂ h₁               --&gt; Example of currying
#check h₂ h₁ x
</code></pre>
<p>Note: Currying is named after the Logician Haskel Curry, who studied Electrical Engineering at MIT in the 1920s, although he eventually switched to Physics.</p>
<h2 id="type-errors"><a class="header" href="#type-errors">Type Errors</a></h2>
<p>The typed lambda calculus disallows expressions that do not follow typing rules. For example, the following expression produces a type error</p>
<pre><code class="language-lean">#check_failure λ (g : A) =&gt; λ (y : A) =&gt; g y
</code></pre>
<p>because g is not declared to be a function type and therefore cannot be applied to y.</p>
<p>Another example is</p>
<pre><code class="language-lean">#check_failure λ (y : A) =&gt; q
</code></pre>
<p>about which Lean complains because q has not been declared in the present context.</p>
<h2 id="judgements-and-contexts"><a class="header" href="#judgements-and-contexts">Judgements and Contexts</a></h2>
<p>When you hover over a #check directive, Lean shows the results of the type derivation as what is called a <strong>judgement</strong>. It is an expression in two parts separated by a <strong>turnstile</strong> ⊢. For example: <code>#check h₁ x</code> produces</p>
<pre><code>x : A
f : A → A
⊢ A
</code></pre>
<p>Before the turnstile is the <strong>context</strong>, a list of all the variables introduced so far. After the turnstile is the type of (h₁ x), which in this case is A. In the literature, this written:</p>
<pre><code>{ x : A, f : A → A }  ⊢  h₁ x : A
</code></pre>
<p>which reads: "If A has type A and f has type A → A, then we can derive h₁ x has type A". In an expression such as</p>
<pre><code>λ (y : A) =&gt; f y
</code></pre>
<p>the variable f is not bound to an enclosing lambda. In this case it is called <strong>free</strong>. The variable y on the other hand is <code>bound</code>. Free variables have to be declared in Lean for expressions to use them. And they have to have types consistent to how they are used. When this is done properly, you will see the free variable declarations in the context part of Lean's results.</p>
<h2 id="beta-reduction"><a class="header" href="#beta-reduction">Beta Reduction</a></h2>
<p>An abstraction can be <code>applied</code> to another term to produce a new term. This is called β-reduction. It is defined like this:</p>
<pre><code>(λ (x:α) =&gt; M) N   —β→   M[x:=N]
</code></pre>
<p>The notation <code>M[x:=N]</code> means: take all <strong>free</strong> occurances of <code>x</code> in <code>M</code> and replace them with the expression N. We have to be careful that <code>N</code> does not use the variable <code>x</code> freely. Lean does this internally for us The bound version of <code>x</code> above is, internally, a completely unique variable that is just displayed as <code>x</code> for our convenience.</p>
<p>To apply β-reduction in Lean, you can use the #reduce directive. For example, we can see that</p>
<pre><code>(λ (g : α → α) =&gt; λ (y : α) =&gt; g y) f   —β→   λ (y : α) =&gt; f y
</code></pre>
<p>This is obtained by replacing <code>g</code> in <code>g y</code> with <code>f</code>, as the rule describes. You can have Lean do this for you using the #reduce directive. The <code>#reduce</code> directive needs permission to be aggressive, which we can do using the <code>(types := true)</code> option.</p>
<pre><code class="language-lean">#reduce (types:=true) (λ (y : A) =&gt; y) x
#reduce (types:=true) (λ (g : A → A) =&gt; λ (y : A) =&gt; g y) (λ (y : A) =&gt; y)
#reduce (types:=true) (λ (g : A → A) =&gt; λ (y : A) =&gt; g y) (λ (y : A) =&gt; y) x
</code></pre>
<h2 id="properties-of-the-simply-typed-λ-calculus"><a class="header" href="#properties-of-the-simply-typed-λ-calculus">Properties of the Simply Typed λ-calculus</a></h2>
<p>Some interesting observations are in order. We won't prove these here, but they are good to know:</p>
<p><strong>Uniqueness of Types</strong>: Every term has exacly one type.</p>
<p><strong>Subject Reduction Lemma</strong>: If <code>M₁ : α and M₁ —β→ M₂</code> then <code>M₂ : α</code>. That is, beta reduction does't change the type of expressions. It just simplifies them.</p>
<p><strong>Church-Rosser Theorem</strong>: If <code>M —β→ N₁</code> and <code>M —β→ N₂</code> then there is some <code>N₃</code> such that <code>N₁ —β→ N₃</code> and <code>N₂ —β→ N₃</code>. That is, it doesn't matter what order you β-reduce an expression's sub-expressions in, you always end up with the same term.</p>
<p><strong>Strong Normalization</strong>: β-reduction eventually stops at an irreducible term. This is a very strong statement. In most programming languages, you can write infinite loops. But not in the simply typed λ-calculus!</p>
<h2 id="extended-example-church-numerals"><a class="header" href="#extended-example-church-numerals">Extended Example: Church Numerals</a></h2>
<p>Even though the simply typed λ-calculus looks simple, you can encode quite a bit of math with it. The goal of this next section is to show you how do do arithmetic with only what we have so far (simple arrow types and terms depending only on terms). We do this not because it is efficient -- it isn't! Instead, we want to show that the essence of arithmetic is captured by the simply typed λ-calculus.</p>
<p>First, we need a way to represent numbers. Church devised the following scheme, where c₀ is the <strong>Church Numeral</strong> for 0 and so on.</p>
<pre><code class="language-lean">def α := Type

def c₀ := λ ( f : α → α ) =&gt; λ ( x : α ) =&gt; x
def c₁ := λ ( f : α → α ) =&gt; λ ( x : α ) =&gt; f x
def c₂ := λ ( f : α → α ) =&gt; λ ( x : α ) =&gt; f (f x)
def c₃ := λ ( f : α → α ) =&gt; λ ( x : α ) =&gt; f (f (f x))
</code></pre>
<p>You can check the type of a Church numeral:</p>
<pre><code class="language-lean">#check c₂
</code></pre>
<p>For convenience, let's give this type a name:</p>
<pre><code class="language-lean">def N := (α → α) → α → α

#check N
</code></pre>
<h3 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h3>
<p>We can define functions on numbers. For example, the successor function is defined below.</p>
<pre><code class="language-lean">def succ := λ (m : N) =&gt; λ (f : α → α) =&gt; λ (x: α) =&gt; f (m f x)
</code></pre>
<p>To see how this works, let's apply succ to c₀. We omit the types to make it easier to read. Note for clarity we use the dummy variables g and y in c₀ instead of f and x.</p>
<p>succ c₀ = ( λ m =&gt; λ f =&gt; λ x =&gt; f (m f x) )  ( λ g =&gt; λ y =&gt; y )
—β—&gt; λ f =&gt; λ x =&gt; f ( ( λ g =&gt; λ y =&gt; y ) f x )
[note, g is not used, so f x disappears]
—β—&gt; λ f =&gt; λ x =&gt; f ( ( λ y =&gt; y ) x )
—β—&gt; λ f =&gt; λ x =&gt; f x
= c₁</p>
<p>This is a lot of work, so let's let Lean do this for us:</p>
<pre><code class="language-lean">#reduce (types := true ) succ c₀
#reduce (types := true ) succ c₃
</code></pre>
<h3 id="other-operations"><a class="header" href="#other-operations">Other Operations</a></h3>
<p>We can also add two numbers together:</p>
<pre><code class="language-lean">def add := λ (m : N) =&gt; λ (n : N) =&gt; λ (f : α → α) =&gt; λ (x: α) =&gt; m f (n f x)

#reduce (types := true) add c₃ c₂
#reduce (types := true) add (succ c₃) (add c₁ c₂)
</code></pre>
<p>And here is multiplication:</p>
<pre><code class="language-lean">def mul :=  λ (m : N) =&gt; λ (n : N) =&gt; λ (f : α → α) =&gt; λ (x: α) =&gt; m (n f) x

#reduce (types := true) mul c₃ c₂
</code></pre>
<p>We can even do a sort of if-statement:</p>
<pre><code class="language-lean">def ifzero := λ (m : N) =&gt; λ (n : N) =&gt; λ (p : N) =&gt;
              λ (f : α → α) =&gt; λ (x: α) =&gt;
              n (λ ( y : _ ) =&gt; p f x) (m f x)

#reduce (types := true) ifzero c₂ c₀ c₃
#reduce (types := true) ifzero c₂ c₁ c₃
</code></pre>
<h3 id="lean-can-prove-11--2"><a class="header" href="#lean-can-prove-11--2">LEAN CAN PROVE 1+1 = 2</a></h3>
<pre><code class="language-lean">theorem one_plus_one_is_two : add c₁ c₁ = c₂ :=
  rfl
</code></pre>
<p>You can prove this by rfl because, as we will see, two lambda expressions that beta reduce to the same thing are considered <code>definitionally equal</code>. Although this is not scalable and in fact Lean has a much more expressive type system that we will harness soon.</p>
<p>/- ## References</p>
<p>Alonzo Church
<a href="https://www.jstor.org/stable/2371045">An Unsolvable Problem of Elementary Number Theory</a>.
American Journal of Mathematics, 1936.</p>
<p>Haskell B Curry
<a href="https://www.cambridge.org/core/journals/journal-of-symbolic-logic/article/abs/inconsistency-of-certain-formal-logics/FF38B653569E479408EC4DDD26DD7918">The Inconsistency of Certain Formal Logics</a>.
The Journal of Symbolic Logic, 1942.</p>
<p>Alonzo Church
<a href="http://www.classes.cs.uchicago.edu/archive/2007/spring/32001-1/papers/church-1940.pdf">A formulation of the simple theory of types</a>.
Journal of Symbolic Logic, 1940</p>
<p>Uwe Nestmann and Students
<a href="https://www.youtube.com/playlist?list=PLNwzBl6BGLwOKBFVbvp-GFjAA_ESZ--q4">The Lambda Cube Unboxed</a>.
YouTube, 2020</p>
<div style='height=50px'>&nbsp;</div><hr>
Copyright © 2025 Eric Klavins

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="Lean.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="Types.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="Lean.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="Types.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="highlight.js"></script>
        <script src="lean-book.js"></script>


    </div>
    </body>
</html>
